<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ZERO OVERDRIVE</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root { --neon-blue: #00f2ff; --neon-pink: #ff00ea; --neon-lime: #a2ff00; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; touch-action: none; }

        /* HUD - Опустил ниже */
        #hud {
            position: fixed; top: 80px; left: 30px; 
            color: white; pointer-events: none;
            border-left: 3px solid var(--neon-blue); padding-left: 15px; z-index: 10;
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
        }
        #score-label { font-size: 14px; letter-spacing: 4px; color: var(--neon-blue); text-transform: uppercase; }
        #score { font-size: 42px; font-weight: 700; margin-top: -5px; line-height: 1; }

        /* UI Экраны */
        #overlay {
            position: fixed; inset: 0; display: flex; flex-direction: column;
            justify-content: center; align-items: center; 
            background: radial-gradient(circle, rgba(5,5,15,0.8) 0%, rgba(0,0,0,1) 100%);
            backdrop-filter: blur(10px); z-index: 100; transition: 0.5s;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 50px 40px; border-radius: 30px; text-align: center;
            width: 90%; max-width: 440px; box-shadow: 0 0 50px rgba(0,0,0,1);
        }

        h1 { color: #fff; font-size: 40px; margin: 0; letter-spacing: 10px; font-weight: 700; text-transform: uppercase; }
        h1 span { color: var(--neon-pink); }
        
        .btn {
            margin-top: 40px; padding: 18px 0; width: 100%; background: transparent;
            color: white; border: 1px solid var(--neon-blue); font-family: 'Rajdhani';
            font-size: 20px; letter-spacing: 5px; cursor: pointer; transition: 0.3s;
            text-transform: uppercase; border-radius: 4px;
        }
        .btn:hover { background: var(--neon-blue); color: #000; box-shadow: 0 0 40px var(--neon-blue); }

        #hint { position: absolute; bottom: 50px; color: rgba(255,255,255,0.3); font-size: 13px; letter-spacing: 3px; }
    </style>
</head>
<body>

<div id="hud">
    <div id="score-label">Distance</div>
    <div id="score">0</div>
</div>

<div id="overlay">
    <div class="glass-card">
        <h1 id="title">ZONE<span>X</span></h1>
        <p style="color: var(--neon-blue); opacity: 0.6; margin-top: 10px; letter-spacing: 2px;">NEURAL LINK READY</p>
        <button class="btn" onclick="startGame()">Start</button>
    </div>
    <div id="hint">HP+ STUDIO</div>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';

    let scene, camera, renderer, composer, ship, tunnelSegments = [];
    let speed = 0.8, score = 0, isPlaying = false;
    let targetX = 0, targetY = 0;
    let obstacles = [];

    const COLORS = [0x00f2ff, 0xff00ea, 0xa2ff00, 0xffd700];

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000005, 0.01);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Максимальное разрешение
        document.body.appendChild(renderer.domElement);

        // Эффект свечения (Bloom)
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.0; 
        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        // Создание детализированного корабля
        createShip();
        
        // Создание туннеля (несколько секций для бесконечности)
        for(let i=0; i<5; i++) {
            createTunnelSegment(i * -100);
        }

        setupControls();
        window.addEventListener('resize', onResize);
        animate();
    }

    function createShip() {
        ship = new THREE.Group();
        
        // Корпус
        const body = new THREE.Mesh(
            new THREE.ConeGeometry(0.5, 2.5, 4),
            new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 1, roughness: 0.2 })
        );
        body.rotation.x = Math.PI / 2;
        ship.add(body);

        // Светящиеся линии на крыльях
        const wingGeo = new THREE.BoxGeometry(2.5, 0.05, 0.8);
        const wingMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff });
        const wings = new THREE.Mesh(wingGeo, wingMat);
        ship.add(wings);

        // Двигатели (два пламени)
        const engineGeo = new THREE.CylinderGeometry(0.15, 0, 1.5);
        const engineMat = new THREE.MeshBasicMaterial({ color: 0xff00ea });
        
        const e1 = new THREE.Mesh(engineGeo, engineMat);
        e1.position.set(0.4, 0, 1.5); e1.rotation.x = Math.PI / 2;
        ship.add(e1);
        
        const e2 = new THREE.Mesh(engineGeo, engineMat);
        e2.position.set(-0.4, 0, 1.5); e2.rotation.x = Math.PI / 2;
        ship.add(e2);

        scene.add(ship);
    }

    function createTunnelSegment(z) {
        const group = new THREE.Group();
        
        // Сами стенки туннеля (сетка)
        const geo = new THREE.CylinderGeometry(20, 20, 100, 12, 1, true);
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0x111133, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.2,
            side: THREE.BackSide 
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI / 2;
        group.add(mesh);

        // Яркие энергетические кольца
        for(let i=0; i<5; i++) {
            const rGeo = new THREE.TorusGeometry(19.8, 0.1, 8, 48);
            const rMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff });
            const ring = new THREE.Mesh(rGeo, rMat);
            ring.position.z = i * 20 - 50;
            group.add(ring);
        }

        group.position.z = z;
        scene.add(group);
        tunnelSegments.push(group);
    }

    function createObstacle() {
        const types = [
            new THREE.IcosahedronGeometry(Math.random() * 2 + 1),
            new THREE.BoxGeometry(2, 2, 2),
            new THREE.TorusGeometry(2, 0.5, 10, 20)
        ];
        const geo = types[Math.floor(Math.random() * types.length)];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        
        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
            color: 0x000000, 
            emissive: color, 
            emissiveIntensity: 2 
        }));
        
        // Распределяем по всему объему туннеля
        mesh.position.set((Math.random()-0.5)*25, (Math.random()-0.5)*25, -200);
        scene.add(mesh);
        obstacles.push(mesh);
    }

    function setupControls() {
        const move = (x, y) => {
            targetX = (x / window.innerWidth - 0.5) * 22;
            targetY = -(y / window.innerHeight - 0.5) * 18;
        };
        window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            move(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
    }

    function animate() {
        requestAnimationFrame(animate);

        if (isPlaying) {
            // Движение корабля в 3D (X и Y)
            ship.position.x += (targetX - ship.position.x) * 0.08;
            ship.position.y += (targetY - ship.position.y) * 0.08;
            
            // Динамические наклоны
            ship.rotation.z = -(targetX - ship.position.x) * 0.4;
            ship.rotation.x = (targetY - ship.position.y) * 0.3;
            ship.rotation.y = (targetX - ship.position.x) * 0.1;

            // Камера плавает за кораблем
            camera.position.x += (ship.position.x - camera.position.x) * 0.05;
            camera.position.y += (ship.position.y + 1.5 - camera.position.y) * 0.05;

            score += speed;
            document.getElementById('score').innerText = Math.floor(score);
            speed += 0.0002;

            // Движение туннеля
            tunnelSegments.forEach(seg => {
                seg.position.z += speed * 2;
                if(seg.position.z > 100) seg.position.z -= 500;
            });

            // Препятствия
            if (Math.random() < 0.06 + (speed/50)) createObstacle();
            
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].position.z += speed * 2;
                obstacles[i].rotation.y += 0.02;
                
                // Коллизия (проверка расстояния)
                if (obstacles[i].position.distanceTo(ship.position) < 2.2) {
                    gameOver();
                }

                if (obstacles[i].position.z > 20) {
                    scene.remove(obstacles[i]);
                    obstacles.splice(i, 1);
                }
            }
        }

        composer.render();
    }

    function gameOver() {
        isPlaying = false;
        document.getElementById('overlay').style.opacity = '1';
        document.getElementById('overlay').style.pointerEvents = 'all';
        document.getElementById('title').innerHTML = '<span>CRASH</span>';
        document.getElementById('msg');
    }

    window.startGame = () => {
        score = 0; speed = 0.8;
        obstacles.forEach(o => scene.remove(o));
        obstacles = [];
        isPlaying = true;
        document.getElementById('overlay').style.opacity = '0';
        document.getElementById('overlay').style.pointerEvents = 'none';
    };

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
</script>
</body>
</html>