<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web 3D Engine</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        .ui-panel { background: rgba(30, 30, 30, 0.9); border: 1px solid #444; backdrop-filter: blur(5px); }
        input[type="range"] { accent-color: #3b82f6; }
        input[type="color"] { border: none; width: 30px; height: 30px; padding: 0; background: none; cursor: pointer; }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #222; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #777; }
    </style>
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="text-white select-none">

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Top Toolbar (Creation & Modes) -->
    <div class="ui-panel fixed top-0 left-0 w-full p-2 flex items-center justify-between z-10 box-border">
        <div class="flex items-center gap-2">
            <span class="font-bold text-blue-400 mr-2">MiniUnity</span>
            
            <!-- Creation Buttons -->
            <div class="flex gap-1 bg-gray-700 p-1 rounded">
                <button id="btn-block" class="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm transition">üßä –ë–ª–æ–∫</button>
                <button id="btn-sphere" class="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm transition">‚ö™ –®–∞—Ä</button>
                <button id="btn-stairs" class="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm transition">ü™ú –õ–µ—Å—Ç–Ω–∏—Ü–∞</button>
                <button id="btn-player" class="px-3 py-1 bg-green-700 hover:bg-green-600 rounded text-sm transition border border-green-500">üë§ –ò–≥—Ä–æ–∫</button>
            </div>

            <div class="w-px h-6 bg-gray-600 mx-1"></div>

            <!-- Transform Tools -->
            <div class="flex gap-1 bg-gray-700 p-1 rounded" id="transform-tools">
                <button data-mode="translate" class="tool-btn px-3 py-1 bg-blue-600 rounded text-sm transition">Move</button>
                <button data-mode="rotate" class="tool-btn px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm transition">Rotate</button>
                <button data-mode="scale" class="tool-btn px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm transition">Size</button>
            </div>
        </div>

        <div class="flex items-center gap-2">
            <button id="btn-save" class="px-4 py-1.5 bg-purple-700 hover:bg-purple-600 rounded text-sm font-bold flex items-center gap-1">
                üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å HTML
            </button>
            <div class="w-px h-6 bg-gray-600 mx-1"></div>
            <button id="btn-test" class="px-6 py-1.5 bg-green-600 hover:bg-green-500 rounded text-sm font-bold shadow-lg shadow-green-900/50">‚ñ∂ –¢–µ—Å—Ç</button>
            <button id="btn-stop" class="hidden px-6 py-1.5 bg-red-600 hover:bg-red-500 rounded text-sm font-bold shadow-lg shadow-red-900/50">‚èπ –°—Ç–æ–ø</button>
        </div>
    </div>

    <!-- Right Inspector Panel -->
    <div id="inspector" class="ui-panel fixed top-14 right-4 w-64 p-4 rounded-lg shadow-xl hidden flex-col gap-4 z-10">
        <div class="flex justify-between items-center border-b border-gray-600 pb-2">
            <h3 class="font-bold text-lg text-gray-200">–ò–Ω—Å–ø–µ–∫—Ç–æ—Ä</h3>
            <button id="btn-delete" class="text-red-400 hover:text-red-300 text-xs uppercase font-bold">–£–¥–∞–ª–∏—Ç—å</button>
        </div>

        <!-- Dynamic Properties -->
        <div class="space-y-3">
            <div class="flex items-center justify-between">
                <label class="text-gray-400 text-sm">–¶–≤–µ—Ç</label>
                <input type="color" id="inp-color" value="#ffffff">
            </div>

            <div id="prop-transparency" class="space-y-1">
                <div class="flex justify-between">
                    <label class="text-gray-400 text-sm">Transparency</label>
                    <span id="val-transparency" class="text-xs text-gray-500">0</span>
                </div>
                <input type="range" id="inp-transparency" min="0" max="1" step="0.1" value="0" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            </div>

            <div id="prop-cancollide" class="flex items-center justify-between bg-gray-800 p-2 rounded border border-gray-700">
                <label class="text-gray-400 text-sm">CanCollide</label>
                <input type="checkbox" id="inp-cancollide" class="w-4 h-4 rounded text-blue-600 focus:ring-blue-500 bg-gray-700 border-gray-600">
            </div>
            
            <div class="text-xs text-gray-500 mt-2 border-t border-gray-700 pt-2">
                Type: <span id="lbl-type" class="text-gray-300">Object</span>
            </div>
        </div>
    </div>

    <!-- Instructions Overlay -->
    <div id="instructions" class="fixed bottom-4 left-4 text-xs text-gray-400 pointer-events-none opacity-70">
        Left Click: Select<br>
        Right Click: Rotate Camera<br>
        Test Mode: WASD to Move, Space to Jump, ESC to release mouse
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let orbitControls, transformControls, pointerControls;
        let objects = []; // All interactable objects
        let playerObj = null; // Reference to the player spawn marker
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // State
        let selectedObject = null;
        let isTestMode = false;
        let originalPositions = new Map(); // Store state before testing

        // Game Physics Variables
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        const GRAVITY = 30; // m/s¬≤
        const WALK_SPEED = 10;
        const JUMP_FORCE = 15;

        // --- INITIALIZATION ---
        init();
        animate();

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            // Grid
            const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x333333);
            scene.add(gridHelper);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls (Editor)
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;

            // Transform Controls
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', function (event) {
                orbitControls.enabled = !event.value;
            });
            transformControls.addEventListener('change', () => {
                // Update properties if changed via gizmo
                if (selectedObject) updateInspectorUI(selectedObject);
            });
            scene.add(transformControls);

            // Controls (Test Mode)
            pointerControls = new PointerLockControls(camera, document.body);
            pointerControls.addEventListener('lock', () => {
                // Game started
            });
            pointerControls.addEventListener('unlock', () => {
                // If user pressed ESC
                if (isTestMode) {
                   // Optional: Pause menu logic could go here
                }
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);

            setupUI();
        }

        // --- OBJECT CREATION ---

        function createMaterial(color = 0x999999) {
            return new THREE.MeshStandardMaterial({ 
                color: color, 
                transparent: false, 
                opacity: 1 
            });
        }

        function setupObject(mesh, type) {
            mesh.userData.isInteractable = true;
            mesh.userData.type = type;
            mesh.userData.canCollide = true; // Default
            mesh.userData.transparency = 0; // Default
            
            // Allow casting shadows
            if (mesh.isGroup) {
                mesh.children.forEach(c => {
                    if (c.isMesh) {
                        c.castShadow = true;
                        c.receiveShadow = true;
                    }
                });
            } else {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
            }

            scene.add(mesh);
            objects.push(mesh);
            selectObject(mesh);
        }

        function createBlock() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = createMaterial(0x3b82f6); // Blueish
            const cube = new THREE.Mesh(geometry, material);
            cube.position.y = 0.5;
            setupObject(cube, "Block");
        }

        function createSphere() {
            const geometry = new THREE.SphereGeometry(0.5, 32, 16);
            const material = createMaterial(0xef4444); // Reddish
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.y = 0.5;
            setupObject(sphere, "Sphere");
        }

        function createStairs() {
            const group = new THREE.Group();
            const stepMat = createMaterial(0xeab308); // Yellowish
            
            for(let i=0; i<5; i++) {
                const stepGeo = new THREE.BoxGeometry(1, 0.2, 0.4);
                const step = new THREE.Mesh(stepGeo, stepMat.clone());
                step.position.set(0, i * 0.2 + 0.1, i * -0.4);
                step.castShadow = true;
                step.receiveShadow = true;
                group.add(step);
            }
            
            // Make group selectable via a bounding box helper or raycast logic. 
            // For simplicity, we wrap it in a parent object that holds the userData.
            group.position.y = 0;
            
            // To make raycasting work on the group easily, we need to traverse.
            // But let's attach data to the group.
            setupObject(group, "Stairs");
        }

        function createPlayer() {
            if (playerObj) {
                scene.remove(playerObj);
                objects = objects.filter(o => o !== playerObj);
                if(selectedObject === playerObj) deselectObject();
            }

            const geometry = new THREE.CapsuleGeometry(0.4, 1, 4, 8);
            const material = createMaterial(0x22c55e); // Green
            const player = new THREE.Mesh(geometry, material);
            player.position.set(0, 1, 0);
            
            // Specific Player Props
            player.userData.isInteractable = true;
            player.userData.type = "Player";
            player.userData.canCollide = false; // Player logic handles collision, this flag is for OTHERS colliding with it
            player.userData.isPlayerStart = true;
            
            scene.add(player);
            objects.push(player);
            playerObj = player;
            selectObject(player);
        }

        // --- SELECTION & MANIPULATION ---

        function onPointerDown(event) {
            if (isTestMode) return;
            if (event.button !== 0) return; // Only left click

            // Calculate mouse position
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Raycast against all interactable objects
            // Note: For groups (Stairs), we need recursive=true
            const intersects = raycaster.intersectObjects(objects, true);

            if (intersects.length > 0) {
                let hit = intersects[0].object;
                
                // Climb up to the main container if it's part of a group
                while(hit.parent && hit.parent !== scene) {
                    if (objects.includes(hit.parent)) {
                        hit = hit.parent;
                        break;
                    }
                    hit = hit.parent;
                }
                
                if (objects.includes(hit)) {
                    selectObject(hit);
                    return;
                }
            }
            
            // Deselect if clicked empty space
            deselectObject();
        }

        function selectObject(obj) {
            selectedObject = obj;
            transformControls.attach(obj);
            
            // Show UI
            document.getElementById('inspector').classList.remove('hidden');
            document.getElementById('inspector').classList.add('flex');
            
            updateInspectorUI(obj);
        }

        function deselectObject() {
            selectedObject = null;
            transformControls.detach();
            document.getElementById('inspector').classList.add('hidden');
            document.getElementById('inspector').classList.remove('flex');
        }

        // --- UI & PROPERTIES ---

        function setupUI() {
            // Creation
            document.getElementById('btn-block').onclick = createBlock;
            document.getElementById('btn-sphere').onclick = createSphere;
            document.getElementById('btn-stairs').onclick = createStairs;
            document.getElementById('btn-player').onclick = createPlayer;
            document.getElementById('btn-delete').onclick = () => {
                if(selectedObject) {
                    if(selectedObject === playerObj) playerObj = null;
                    scene.remove(selectedObject);
                    objects = objects.filter(o => o !== selectedObject);
                    deselectObject();
                }
            };

            // Modes
            document.getElementById('btn-test').onclick = startTestMode;
            document.getElementById('btn-stop').onclick = stopTestMode;
            document.getElementById('btn-save').onclick = saveHTML;

            // Transform Modes
            const toolBtns = document.querySelectorAll('.tool-btn');
            toolBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const mode = e.target.dataset.mode;
                    transformControls.setMode(mode);
                    // Update visuals
                    toolBtns.forEach(b => b.classList.replace('bg-blue-600', 'bg-gray-600'));
                    e.target.classList.replace('bg-gray-600', 'bg-blue-600');
                });
            });

            // Property Inputs
            const inpColor = document.getElementById('inp-color');
            const inpTransp = document.getElementById('inp-transparency');
            const inpCollide = document.getElementById('inp-cancollide');

            inpColor.addEventListener('input', (e) => {
                if(!selectedObject) return;
                applyColor(selectedObject, e.target.value);
            });

            inpTransp.addEventListener('input', (e) => {
                if(!selectedObject) return;
                const val = parseFloat(e.target.value);
                document.getElementById('val-transparency').innerText = val;
                applyTransparency(selectedObject, val);
            });

            inpCollide.addEventListener('change', (e) => {
                if(!selectedObject) return;
                selectedObject.userData.canCollide = e.target.checked;
            });
        }

        function updateInspectorUI(obj) {
            const isPlayer = (obj.userData.type === "Player");

            // Type Label
            document.getElementById('lbl-type').innerText = obj.userData.type;

            // Color
            // Helper to get hex from mesh
            let mesh = obj.isGroup ? obj.children[0] : obj;
            if(mesh && mesh.material) {
                document.getElementById('inp-color').value = '#' + mesh.material.color.getHexString();
            }

            // Transparency
            const transpContainer = document.getElementById('prop-transparency');
            if (isPlayer) {
                transpContainer.classList.add('hidden');
            } else {
                transpContainer.classList.remove('hidden');
                const tVal = obj.userData.transparency || 0;
                document.getElementById('inp-transparency').value = tVal;
                document.getElementById('val-transparency').innerText = tVal;
            }

            // CanCollide
            const colContainer = document.getElementById('prop-cancollide');
            if (isPlayer) {
                colContainer.classList.add('hidden');
            } else {
                colContainer.classList.remove('hidden');
                document.getElementById('inp-cancollide').checked = obj.userData.canCollide;
            }
        }

        function applyColor(obj, hexColor) {
            if (obj.isGroup) {
                obj.children.forEach(c => {
                    if (c.material) c.material.color.set(hexColor);
                });
            } else {
                if (obj.material) obj.material.color.set(hexColor);
            }
        }

        function applyTransparency(obj, val) {
            // val is 0 (solid) to 1 (invisible)
            // Threejs opacity is 1 (solid) to 0 (invisible)
            const opacity = 1 - val;
            const transparent = val > 0;
            
            obj.userData.transparency = val;

            const updateMat = (mat) => {
                mat.transparent = transparent;
                mat.opacity = opacity;
                mat.needsUpdate = true;
            };

            if (obj.isGroup) {
                obj.children.forEach(c => {
                    if(c.material) updateMat(c.material);
                });
            } else {
                if(obj.material) updateMat(obj.material);
            }
        }

        // --- GAME / TEST MODE LOGIC ---

        function startTestMode() {
            if (!playerObj) {
                alert("–°–æ–∑–¥–∞–π—Ç–µ –∏–≥—Ä–æ–∫–∞ (Player) –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è!");
                return;
            }

            isTestMode = true;
            deselectObject(); // Hide gizmos

            // UI switching
            document.getElementById('btn-test').classList.add('hidden');
            document.getElementById('btn-stop').classList.remove('hidden');
            document.getElementById('transform-tools').classList.add('opacity-50', 'pointer-events-none');
            document.querySelector('.ui-panel').classList.add('pointer-events-none'); // Disable toolbar clicks
            document.getElementById('btn-stop').classList.remove('pointer-events-none'); // Re-enable stop button
            document.getElementById('btn-stop').parentElement.classList.remove('pointer-events-none'); // Re-enable stop container

            // Save positions to restore later
            originalPositions.clear();
            objects.forEach(obj => {
                originalPositions.set(obj, {
                    pos: obj.position.clone(),
                    rot: obj.rotation.clone(),
                    scale: obj.scale.clone()
                });
            });

            // Setup Camera on Player
            pointerControls.lock(); // Request pointer lock
            
            // Move camera to player start
            camera.position.copy(playerObj.position);
            camera.position.y += 0.5; // Eye level
            
            // Hide player model representation during play (optional, usually FPS implies hidden body or looking down)
            playerObj.visible = false;
        }

        function stopTestMode() {
            isTestMode = false;
            pointerControls.unlock();

            // UI switching
            document.getElementById('btn-test').classList.remove('hidden');
            document.getElementById('btn-stop').classList.add('hidden');
            document.getElementById('transform-tools').classList.remove('opacity-50', 'pointer-events-none');
            document.querySelector('.ui-panel').classList.remove('pointer-events-none');

            // Restore objects (in case physics moved them - though here we only move player)
            // But good practice if we add physics boxes later
            objects.forEach(obj => {
                if(originalPositions.has(obj)) {
                    const data = originalPositions.get(obj);
                    obj.position.copy(data.pos);
                    obj.rotation.copy(data.rot);
                    obj.scale.copy(data.scale);
                }
            });

            // Show player model
            if(playerObj) playerObj.visible = true;

            // Reset camera to orbit
            camera.position.set(5, 5, 10);
            camera.lookAt(0,0,0);
        }

        // --- GAME PHYSICS LOOP ---

        function updatePhysics(delta) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 10.0 * delta; // Gravity

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize(); // Ensure consistent speed in all directions

            // --- Horizontal Collision Check ---
            // Calculate intended movement (Reduced speed from 400 to 80 for slower walking)
            const intendedMoveZ = direction.z * 80.0 * delta;
            const intendedMoveX = direction.x * 80.0 * delta;

            if (moveForward || moveBackward) velocity.z -= intendedMoveZ;
            if (moveLeft || moveRight) velocity.x -= intendedMoveX;

            // Apply Horizontal Movement with Collision
            // We check collision BEFORE moving
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            
            // Calculate movement vector in world space
            const moveVector = new THREE.Vector3();
            if(moveForward) moveVector.add(forward);
            if(moveBackward) moveVector.sub(forward);
            if(moveRight) moveVector.add(right);
            if(moveLeft) moveVector.sub(right);
            
            if (moveVector.length() > 0) {
                moveVector.normalize();
                
                // Raycast in direction of movement
                // Cast from lower down (waist/knees) to hit shorter objects like blocks
                const rayOrigin = camera.position.clone();
                rayOrigin.y -= 1.0; 
                raycaster.set(rayOrigin, moveVector);
                // Collect collidables
                const collidables = [];
                objects.forEach(o => {
                    if (o !== playerObj && o.userData.canCollide) {
                        if (o.isGroup) collidables.push(...o.children);
                        else collidables.push(o);
                    }
                });

                const intersects = raycaster.intersectObjects(collidables);
                
                // If hit is very close, stop horizontal movement
                if (intersects.length > 0 && intersects[0].distance < 0.5) {
                    velocity.x = 0;
                    velocity.z = 0;
                }
            }

            pointerControls.moveRight(-velocity.x * delta);
            pointerControls.moveForward(-velocity.z * delta);

            // --- Vertical Collision (Gravity/Floor) ---
            // Raycast down from camera
            raycaster.set(camera.position, new THREE.Vector3(0, -1, 0));
            
            // Collect collidable objects (excluding player marker)
            const collidables = [];
            objects.forEach(o => {
                if (o !== playerObj && o.userData.canCollide) {
                    if (o.isGroup) collidables.push(...o.children);
                    else collidables.push(o);
                }
            });

            const intersections = raycaster.intersectObjects(collidables);
            const onObject = intersections.length > 0 && intersections[0].distance < 1.6;

            if (onObject) {
                velocity.y = Math.max(0, velocity.y);
                canJump = true;
                // Stick to ground slightly
                if (intersections[0].distance < 1.5) {
                    camera.position.y += (1.5 - intersections[0].distance);
                }
            } else {
                // Falling
                canJump = false;
            }
            
            camera.position.y += (velocity.y * delta);

            // Floor check (infinite plane at y=0 if no floor object exists)
            if (camera.position.y < 1.5) {
                velocity.y = 0;
                camera.position.y = 1.5;
                canJump = true;
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = true; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = true; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = true; break;
                case 'Space': 
                    if (canJump && isTestMode) velocity.y += JUMP_FORCE; 
                    canJump = false;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
            }
        }

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            if (isTestMode) {
                const delta = clock.getDelta();
                updatePhysics(delta);
            } else {
                orbitControls.update();
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- SAVE FUNCTIONALITY ---
        function saveHTML() {
            // Serialize scene objects
            const sceneData = objects.map(obj => {
                const data = {
                    type: obj.userData.type,
                    position: obj.position.toArray(),
                    rotation: obj.rotation.toArray().slice(0,3), // Euler to array
                    scale: obj.scale.toArray(),
                    canCollide: obj.userData.canCollide,
                    transparency: obj.userData.transparency || 0,
                    color: '#ffffff'
                };
                
                // Get color
                let mesh = obj.isGroup ? obj.children[0] : obj;
                if(mesh && mesh.material) {
                    data.color = '#' + mesh.material.color.getHexString();
                }
                return data;
            });

            // We will inject this data into the current HTML structure to allow reloading
            // For a robust "Save", we'd usually want a clean loader, but to keep it single-file-ish
            // we will create a script that runs on load to restore this data.

            const jsonString = JSON.stringify(sceneData);

            // Create the content of the new file
            // It's essentially THIS file, but with an auto-load script injection.
            // Since we can't easily read "this file's source" reliably in all browsers locally without fetch,
            // we will generate a simplified Loader HTML or try to fetch documentElement.outerHTML.
            
            const htmlContent = document.documentElement.outerHTML;
            
            // Inject a restore script before the closing body tag
            const restoreScript = `
            <script>
                window.addEventListener('load', () => {
                    setTimeout(() => {
                        restoreScene('${jsonString.replace(/'/g, "\\'")}');
                    }, 500);
                });
                
                function restoreScene(json) {
                    const data = JSON.parse(json);
                    // Clear default scene if any
                    // Assuming init() runs first. 
                    // Note: In a real app we would separate Init from Load.
                    // Here we will just iterate and create.
                    
                    console.log("Restoring scene...", data);
                    
                    // We need to access the create functions globally or expose them.
                    // Since the main script is a module, we can't access them easily from outside unless attached to window.
                    // Let's modify the main module to expose a global restore function.
                }
            <\/script>
            `;
            
            // To make this work with the module scope, we need to handle the restoration INSIDE the module.
            // A simpler way for this demo: Download a JSON file, or download an HTML that contains the JSON in a specific ID.
            
            // Let's go with: Download a .html that HAS the data embedded in a specific <script type="application/json" id="scene-data">.
            
            let outputHTML = htmlContent;
            
            // Check if we already have the data block
            if (outputHTML.includes('id="scene-data"')) {
                outputHTML = outputHTML.replace(/<script id="scene-data" type="application\/json">.*?<\/script>/s, '');
            }
            
            const dataBlock = `<script id="scene-data" type="application/json">${jsonString}<\/script>`;
            outputHTML = outputHTML.replace('</body>', `${dataBlock}</body>`);
            
            // Also need code to READ this on startup. 
            // I will add the reading logic to the main Init function now (see below), 
            // so the saved file works automatically.

            const blob = new Blob([outputHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'my-3d-scene.html';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Add Load Logic to Init (to support the Saved file)
        window.addEventListener('DOMContentLoaded', () => {
             // This event fires before module script sometimes, but let's check inside the module
        });

        // Patching Init to load data if present
        const originalInit = init;
        // We can't easily patch inside this scope for the next reload. 
        // Strategy: The saved HTML will have the script tag.
        // We add a check in the module code to see if that tag exists.
        
        // Add this to the end of init():
        setTimeout(() => {
            const dataScript = document.getElementById('scene-data');
            if (dataScript) {
                try {
                    const data = JSON.parse(dataScript.textContent);
                    // Clear existing demo objects (if any were added by default, though currently none are)
                    objects.forEach(o => scene.remove(o));
                    objects = [];
                    if(playerObj) { scene.remove(playerObj); playerObj = null; }
                    if(transformControls) transformControls.detach();

                    data.forEach(item => {
                        let obj;
                        if(item.type === "Block") { createBlock(); obj = objects[objects.length-1]; }
                        else if(item.type === "Sphere") { createSphere(); obj = objects[objects.length-1]; }
                        else if(item.type === "Stairs") { createStairs(); obj = objects[objects.length-1]; }
                        else if(item.type === "Player") { createPlayer(); obj = playerObj; }

                        if(obj) {
                            obj.position.fromArray(item.position);
                            // Euler reconstruction
                            obj.rotation.set(item.rotation[0], item.rotation[1], item.rotation[2]);
                            obj.scale.fromArray(item.scale);
                            
                            // Properties
                            obj.userData.canCollide = item.canCollide;
                            applyTransparency(obj, item.transparency);
                            applyColor(obj, item.color);
                        }
                    });
                    deselectObject();
                    console.log("Scene loaded from embedded data.");
                } catch(e) {
                    console.error("Failed to load scene data", e);
                }
            }
        }, 100);

    </script>
</body>
</html>