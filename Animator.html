<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–í–µ–∫—Ç–æ—Ä–ê–Ω–∏–º–∞—Ç–æ—Ä (Adobe Animate Clone)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            overscroll-behavior: none;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        .panel-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: bold;
            color: #94a3b8;
        }

        .tool-btn.active {
            background-color: #3b82f6;
            color: white;
        }

        /* Checkboard pattern for transparency */
        #stage-container {
            background-image: 
                linear-gradient(45deg, #2a2a2a 25%, transparent 25%), 
                linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #2a2a2a 75%), 
                linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #1a1a1a;
        }

        .frame-cell {
            border-right: 1px solid #334155;
            border-bottom: 1px solid #334155;
        }
        .frame-cell.active { background-color: #3b82f6; opacity: 0.3; }
        .keyframe { 
            position: relative;
            background-color: #475569; 
        }
        .keyframe::after {
            content: '';
            position: absolute;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            width: 6px; height: 6px;
            background-color: white;
            border-radius: 50%;
        }
        /* Tween line representation */
        .tween-span { background-color: #2563eb; opacity: 0.5; }

        /* Mobile specific adjustments */
        @media (max-width: 768px) {
            #main-layout { flex-direction: column; }
            #toolbar { flex-direction: row; height: 50px; width: 100%; overflow-x: auto; }
            #timeline { height: 150px; }
            #properties { display: none; position: absolute; right: 0; top: 50px; bottom: 150px; background: #1e293b; z-index: 50; width: 200px; }
            #properties.show { display: block; }
        }
    </style>
</head>
<body class="bg-slate-900 text-white h-screen w-screen flex flex-col overflow-hidden font-sans">

    <!-- Top Menu -->
    <header class="h-10 bg-slate-800 border-b border-slate-700 flex items-center px-4 justify-between shrink-0 z-10">
        <div class="flex items-center space-x-4">
            <span class="font-bold text-blue-400">–í–µ–∫—Ç–æ—Ä–ê–Ω–∏–º–∞—Ç–æ—Ä</span>
            <div class="hidden md:flex space-x-3 text-sm text-slate-300">
                <button onclick="app.fileNew()" class="hover:text-white">–§–∞–π–ª</button>
                <button onclick="app.editUndo()" class="hover:text-white">–ü—Ä–∞–≤–∫–∞</button>
                <button onclick="app.viewFit()" class="hover:text-white">–í–∏–¥</button>
                <button onclick="app.togglePanel('properties')" class="md:hidden hover:text-white">–°–≤-–≤–∞</button>
            </div>
        </div>
        <div class="flex items-center space-x-2">
            <button onclick="app.projectSave()" class="bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-xs">–°–æ—Ö—Ä.</button>
            <button onclick="app.exportVideo()" class="bg-blue-600 hover:bg-blue-500 px-3 py-1 rounded text-xs">–≠–∫—Å–ø–æ—Ä—Ç MP4</button>
        </div>
    </header>

    <!-- Main Workspace -->
    <div id="main-layout" class="flex-1 flex overflow-hidden relative">
        
        <!-- Toolbar (Left on desktop, Top on mobile) -->
        <div id="toolbar" class="w-12 bg-slate-800 border-r border-slate-700 flex flex-col items-center py-2 space-y-2 shrink-0 z-20">
            <!-- Icons handled via simple SVGs inside buttons -->
            <button title="–í—ã–¥–µ–ª–µ–Ω–∏–µ (V)" class="tool-btn p-2 rounded hover:bg-slate-700 w-8 h-8 flex items-center justify-center" onclick="app.setTool('select')" id="tool-select">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M7 2l12 11.2-5.8.5 3.3 7.3-2.2.9-3.2-7.4-4.4 4.6z"/></svg>
            </button>
            <button title="–ö–∏—Å—Ç—å (B)" class="tool-btn p-2 rounded hover:bg-slate-700 w-8 h-8 flex items-center justify-center" onclick="app.setTool('brush')" id="tool-brush">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34a.996.996 0 0 0-1.41 0L9 12.25 11.75 15l8.96-8.96a.996.996 0 0 0 0-1.41z"/></svg>
            </button>
            <button title="–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ (R)" class="tool-btn p-2 rounded hover:bg-slate-700 w-8 h-8 flex items-center justify-center" onclick="app.setTool('rect')" id="tool-rect">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>
            </button>
            <button title="–û–≤–∞–ª (O)" class="tool-btn p-2 rounded hover:bg-slate-700 w-8 h-8 flex items-center justify-center" onclick="app.setTool('circle')" id="tool-circle">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>
            </button>
            
            <div class="h-px w-8 bg-slate-600 my-1"></div>
            
            <!-- Color Pickers -->
            <div class="flex flex-col items-center space-y-1">
                <div class="w-6 h-6 rounded border border-slate-500 overflow-hidden relative group">
                    <input type="color" id="fill-color" class="absolute -top-2 -left-2 w-10 h-10 cursor-pointer" value="#3b82f6" onchange="app.updateProperty('fill', this.value)">
                </div>
                <div class="w-6 h-6 rounded border border-slate-500 overflow-hidden relative group">
                    <div class="absolute inset-2 bg-slate-900 z-10 pointer-events-none"></div>
                    <input type="color" id="stroke-color" class="absolute -top-2 -left-2 w-10 h-10 cursor-pointer" value="#000000" onchange="app.updateProperty('stroke', this.value)">
                </div>
            </div>
            
            <div class="h-px w-8 bg-slate-600 my-1"></div>

             <button title="–û—Ç–º–µ–Ω–∏—Ç—å (Ctrl+Z)" class="tool-btn p-2 rounded hover:bg-slate-700 w-8 h-8 flex items-center justify-center" onclick="app.editUndo()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
            </button>

             <!-- Mobile Toggle Properties -->
            <button class="md:hidden mt-auto tool-btn p-2 rounded bg-slate-700 w-8 h-8 flex items-center justify-center text-xs" onclick="document.getElementById('properties').classList.toggle('show')">
               ‚öô
            </button>
        </div>

        <!-- Stage Area -->
        <div id="stage-container" class="flex-1 relative overflow-hidden flex items-center justify-center">
            <div id="canvas-wrapper" class="relative shadow-2xl">
                <canvas id="main-canvas" class="bg-white cursor-crosshair"></canvas>
            </div>
            
            <!-- Floating Timeline Controls for Mobile convenience -->
            <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-slate-800 rounded-full px-4 py-2 flex items-center space-x-4 shadow-lg z-30 opacity-90">
                <button onclick="app.timeline.prevFrame()" class="text-white hover:text-blue-400">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
                </button>
                <button id="play-btn" onclick="app.timeline.togglePlay()" class="text-white hover:text-green-400">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                </button>
                <button onclick="app.timeline.nextFrame()" class="text-white hover:text-blue-400">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
                </button>
            </div>
        </div>

        <!-- Properties Panel (Right) -->
        <div id="properties" class="w-64 bg-slate-800 border-l border-slate-700 flex flex-col p-4 shrink-0 overflow-y-auto hidden md:block">
            <h3 class="panel-header mb-4 border-b border-slate-600 pb-2">–°–≤–æ–π—Å—Ç–≤–∞</h3>
            
            <div class="space-y-4 text-sm">
                <!-- Document Props -->
                <div class="space-y-2">
                    <label class="block text-slate-400">–†–∞–∑–º–µ—Ä –°—Ü–µ–Ω—ã</label>
                    <div class="flex space-x-2">
                        <input type="number" id="prop-w" value="800" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1" onchange="app.resizeStage()">
                        <span class="pt-1">x</span>
                        <input type="number" id="prop-h" value="600" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1" onchange="app.resizeStage()">
                    </div>
                </div>

                <div class="space-y-2">
                    <label class="block text-slate-400">–ö–∞–¥—Ä–æ–≤/—Å–µ–∫ (FPS)</label>
                    <input type="number" id="prop-fps" value="24" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1" onchange="app.setFps(this.value)">
                </div>

                <hr class="border-slate-700">

                <!-- Object Props -->
                <div id="object-props" class="opacity-50 pointer-events-none transition-opacity">
                    <label class="block text-slate-400 mb-2">–í—ã–¥–µ–ª–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç</label>
                    
                    <div class="grid grid-cols-2 gap-2 mb-2">
                        <div>
                            <span class="text-xs text-slate-500">X</span>
                            <input type="number" id="obj-x" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-xs" onchange="app.updateSelected('x', this.value)">
                        </div>
                        <div>
                            <span class="text-xs text-slate-500">Y</span>
                            <input type="number" id="obj-y" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-xs" onchange="app.updateSelected('y', this.value)">
                        </div>
                        <div>
                            <span class="text-xs text-slate-500">–®–∏—Ä–∏–Ω–∞</span>
                            <input type="number" id="obj-w" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-xs" onchange="app.updateSelected('width', this.value)">
                        </div>
                        <div>
                            <span class="text-xs text-slate-500">–í—ã—Å–æ—Ç–∞</span>
                            <input type="number" id="obj-h" class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-xs" onchange="app.updateSelected('height', this.value)">
                        </div>
                    </div>
                    
                    <div class="space-y-2">
                         <label class="block text-xs text-slate-500">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å</label>
                         <input type="range" id="obj-alpha" min="0" max="1" step="0.1" class="w-full" oninput="app.updateSelected('alpha', this.value)">
                    </div>
                </div>

                <hr class="border-slate-700">

                <div class="space-y-2">
                    <label class="block text-slate-400">–ö–ª—é—á–µ–≤–æ–π –∫–∞–¥—Ä</label>
                    <button onclick="app.timeline.addKeyframe()" class="w-full bg-slate-700 hover:bg-slate-600 py-1 rounded text-xs mb-1">–°–æ–∑–¥–∞—Ç—å –ö–ª—é—á (F6)</button>
                    <button onclick="app.timeline.clearKeyframe()" class="w-full bg-slate-700 hover:bg-slate-600 py-1 rounded text-xs">–û—á–∏—Å—Ç–∏—Ç—å (F7)</button>
                    <div class="flex items-center space-x-2 mt-2">
                        <input type="checkbox" id="chk-tween" onchange="app.timeline.toggleTween()">
                        <span class="text-xs">Tween (–î–≤–∏–∂–µ–Ω–∏–µ)</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Timeline (Bottom) -->
    <div id="timeline" class="h-48 bg-slate-800 border-t border-slate-700 flex flex-col shrink-0 z-20">
        <!-- Timeline Toolbar -->
        <div class="h-8 bg-slate-700 flex items-center px-2 space-x-2 border-b border-slate-600">
            <button onclick="app.timeline.addLayer()" class="text-xs bg-slate-600 hover:bg-slate-500 px-2 py-1 rounded">+ –°–ª–æ–π</button>
            <button onclick="app.timeline.deleteLayer()" class="text-xs bg-red-900 hover:bg-red-800 px-2 py-1 rounded">–£–¥–∞–ª–∏—Ç—å</button>
            <div class="flex-1"></div>
            <span class="text-xs text-slate-400" id="frame-indicator">–ö–∞–¥—Ä: 1</span>
        </div>

        <!-- Timeline Grid -->
        <div class="flex-1 flex overflow-hidden">
            <!-- Layers List -->
            <div class="w-32 bg-slate-800 border-r border-slate-700 flex flex-col overflow-y-auto" id="layers-list">
                <!-- Layers injected via JS -->
            </div>
            
            <!-- Frames Grid -->
            <div class="flex-1 bg-slate-900 overflow-auto relative" id="timeline-grid-container">
                <canvas id="timeline-canvas" height="200"></canvas>
            </div>
        </div>
    </div>

    <!-- Logic -->
    <script>
        /**
         * Core Application Logic
         */
        const CONFIG = {
            gridSize: 20, // Timeline cell width
            rowHeight: 30, // Timeline row height
            maxFrames: 200
        };

        class App {
            constructor() {
                this.canvas = document.getElementById('main-canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: true }); // Optimized
                this.ctx.imageSmoothingEnabled = true;

                this.state = {
                    width: 800,
                    height: 600,
                    fps: 24,
                    zoom: 1,
                    pan: { x: 0, y: 0 },
                    currentFrame: 1,
                    isPlaying: false,
                    tool: 'select', // select, brush, rect, circle
                    fillColor: '#3b82f6',
                    strokeColor: '#000000',
                    lineWidth: 2,
                    isDrawing: false,
                    selection: null, // Selected object ID
                    clipboard: null,
                    
                    // Project Data
                    layers: [
                        {
                            id: 'layer1',
                            name: '–°–ª–æ–π 1',
                            visible: true,
                            locked: false,
                            keyframes: {
                                1: { shapes: [], tween: false }
                            }
                        }
                    ],
                    activeLayerId: 'layer1'
                };

                this.history = []; // Undo stack
                
                this.init();
            }

            init() {
                this.resizeStage();
                this.ui = new UIManager(this);
                this.timeline = new TimelineManager(this);
                this.renderer = new Renderer(this);
                this.input = new InputManager(this);
                
                // Initial Render
                this.timeline.render();
                this.renderer.render();

                // Start Loop
                this.lastTime = 0;
                requestAnimationFrame(this.animate.bind(this));
            }

            resizeStage() {
                const w = parseInt(document.getElementById('prop-w').value) || 800;
                const h = parseInt(document.getElementById('prop-h').value) || 600;
                this.state.width = w;
                this.state.height = h;
                this.canvas.width = w;
                this.canvas.height = h;
                this.renderer && this.renderer.render();
            }

            setTool(toolName) {
                this.state.tool = toolName;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                const btn = document.getElementById('tool-' + toolName);
                if(btn) btn.classList.add('active');
                
                // Deselect if switching drawing tools
                if (toolName !== 'select') {
                    this.state.selection = null;
                    this.ui.updateProperties();
                    this.renderer.render();
                }
            }
            
            setFps(val) {
                this.state.fps = parseInt(val) || 24;
            }

            updateProperty(type, value) {
                if (type === 'fill') this.state.fillColor = value;
                if (type === 'stroke') this.state.strokeColor = value;
                
                // Update selected object if exists
                if (this.state.selection) {
                    const obj = this.getCurrentFrameShapes().find(s => s.id === this.state.selection);
                    if (obj) {
                        if (type === 'fill') obj.fill = value;
                        if (type === 'stroke') obj.stroke = value;
                        this.saveStateToHistory();
                        this.renderer.render();
                    }
                }
            }

            updateSelected(prop, value) {
                if (!this.state.selection) return;
                const shapes = this.getCurrentFrameShapes();
                const obj = shapes.find(s => s.id === this.state.selection);
                if (obj) {
                    obj[prop] = parseFloat(value);
                    this.renderer.render();
                }
            }

            // --- History ---
            saveStateToHistory() {
                // Deep clone layers for undo (simplified)
                const snapshot = JSON.stringify(this.state.layers);
                this.history.push(snapshot);
                if (this.history.length > 20) this.history.shift();
            }

            editUndo() {
                if (this.history.length === 0) return;
                const prev = this.history.pop();
                this.state.layers = JSON.parse(prev);
                this.state.selection = null;
                this.renderer.render();
                this.timeline.render();
            }

            // --- Helpers ---
            getActiveLayer() {
                return this.state.layers.find(l => l.id === this.state.activeLayerId);
            }

            getCurrentKeyframe(layer) {
                // Find the keyframe active at currentFrame
                let kfFrame = 0;
                // Look backwards from current frame
                for (let f = this.state.currentFrame; f >= 1; f--) {
                    if (layer.keyframes[f]) {
                        kfFrame = f;
                        break;
                    }
                }
                return kfFrame > 0 ? { frame: kfFrame, data: layer.keyframes[kfFrame] } : null;
            }

            getNextKeyframe(layer, startFrame) {
                let nextFrame = -1;
                // Find next keyframe after current
                const frames = Object.keys(layer.keyframes).map(Number).sort((a,b)=>a-b);
                for (let f of frames) {
                    if (f > startFrame) {
                        nextFrame = f;
                        break;
                    }
                }
                return nextFrame > 0 ? { frame: nextFrame, data: layer.keyframes[nextFrame] } : null;
            }

            getCurrentFrameShapes() {
                const layer = this.getActiveLayer();
                const kf = this.getCurrentKeyframe(layer);
                return kf ? kf.data.shapes : [];
            }
            
            // --- File ---
            projectSave() {
                const data = JSON.stringify(this.state);
                localStorage.setItem('vectorAnimator_project', data);
                alert('–ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ!');
            }
            
            fileNew() {
                if(confirm("–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç? –ù–µ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç —É—Ç–µ—Ä—è–Ω—ã.")) {
                    localStorage.removeItem('vectorAnimator_project');
                    location.reload();
                }
            }

            // --- Export ---
            exportVideo() {
                if (this.state.isPlaying) this.timeline.togglePlay();
                
                const stream = this.canvas.captureStream(this.state.fps);
                const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                const chunks = [];
                
                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'animation.webm';
                    a.click();
                    alert('–í–∏–¥–µ–æ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ! (WebM)');
                };

                recorder.start();
                
                // Play through all frames
                this.state.currentFrame = 1;
                this.state.isPlaying = true;
                
                // Determine max frame
                let maxF = 1;
                this.state.layers.forEach(l => {
                    Object.keys(l.keyframes).forEach(k => {
                        if (parseInt(k) > maxF) maxF = parseInt(k);
                    });
                });

                // Auto-stop logic in animate loop
                this.isExporting = true;
                this.exportMaxFrame = maxF;
                this.exportRecorder = recorder;
            }
            
            // --- Loop ---
            animate(time) {
                if (this.state.isPlaying) {
                    if (time - this.lastTime > (1000 / this.state.fps)) {
                        this.state.currentFrame++;
                        
                        // Check export end
                        if (this.isExporting && this.state.currentFrame > this.exportMaxFrame) {
                            this.state.isPlaying = false;
                            this.isExporting = false;
                            this.exportRecorder.stop();
                            this.state.currentFrame = 1;
                        } else if (this.state.currentFrame > CONFIG.maxFrames) {
                            this.state.currentFrame = 1;
                        }
                        
                        this.timeline.updateUI();
                        this.renderer.render();
                        this.lastTime = time;
                    }
                }
                requestAnimationFrame(this.animate.bind(this));
            }
            
            // UI Helpers
            viewFit() {
                // Simple reset
                this.state.zoom = 1;
                this.state.pan = {x:0, y:0};
                this.renderer.render();
            }
            
            togglePanel(id) {
                document.getElementById(id).classList.toggle('show');
            }
        }

        /**
         * Rendering Engine
         */
        class Renderer {
            constructor(app) {
                this.app = app;
            }

            render() {
                const ctx = this.app.ctx;
                const state = this.app.state;
                
                // Clear
                ctx.clearRect(0, 0, state.width, state.height);
                
                // Background (White stage)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, state.width, state.height);

                // Iterate Layers (Bottom to Top)
                // In Adobe Animate, top layer in list is drawn LAST (on top)
                // The list is UI order. We iterate array in reverse for drawing? 
                // No, standard array order is usually 0=bottom. Let's assume index 0 is bottom.
                
                state.layers.forEach(layer => {
                    if (!layer.visible) return;

                    const currentKF = this.app.getCurrentKeyframe(layer);
                    
                    if (currentKF) {
                        let shapesToDraw = currentKF.data.shapes;
                        
                        // Handle Tweening Logic (Simple Linear Interpolation)
                        if (currentKF.data.tween) {
                            const nextKF = this.app.getNextKeyframe(layer, currentKF.frame);
                            if (nextKF) {
                                // Calculate percentage
                                const totalFrames = nextKF.frame - currentKF.frame;
                                const passedFrames = state.currentFrame - currentKF.frame;
                                const t = passedFrames / totalFrames; // 0 to 1

                                // We need to interpolate matched shapes.
                                // For simplicity, we interpolate shapes with same ID.
                                shapesToDraw = currentKF.data.shapes.map(s1 => {
                                    const s2 = nextKF.data.shapes.find(s => s.id === s1.id);
                                    if (s2) {
                                        // Clone and interpolate
                                        const interpolated = {...s1};
                                        interpolated.x = s1.x + (s2.x - s1.x) * t;
                                        interpolated.y = s1.y + (s2.y - s1.y) * t;
                                        interpolated.width = s1.width + (s2.width - s1.width) * t;
                                        interpolated.height = s1.height + (s2.height - s1.height) * t;
                                        interpolated.alpha = (s1.alpha !== undefined ? s1.alpha : 1) + ((s2.alpha !== undefined ? s2.alpha : 1) - (s1.alpha !== undefined ? s1.alpha : 1)) * t;
                                        return interpolated;
                                    }
                                    return s1;
                                });
                            }
                        }

                        // Draw Shapes
                        shapesToDraw.forEach(shape => {
                            ctx.globalAlpha = shape.alpha !== undefined ? shape.alpha : 1.0;
                            ctx.fillStyle = shape.fill;
                            ctx.strokeStyle = shape.stroke;
                            ctx.lineWidth = shape.lineWidth || 2;
                            
                            // Highlight selection
                            if (state.selection === shape.id) {
                                ctx.shadowColor = '#3b82f6';
                                ctx.shadowBlur = 10;
                            } else {
                                ctx.shadowBlur = 0;
                            }

                            ctx.beginPath();
                            if (shape.type === 'rect') {
                                ctx.rect(shape.x, shape.y, shape.width, shape.height);
                                ctx.fill();
                                ctx.stroke();
                            } else if (shape.type === 'circle') {
                                ctx.ellipse(shape.x + shape.width/2, shape.y + shape.height/2, Math.abs(shape.width/2), Math.abs(shape.height/2), 0, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.stroke();
                            } else if (shape.type === 'path') {
                                if (shape.points.length > 0) {
                                    ctx.moveTo(shape.points[0].x, shape.points[0].y);
                                    for (let i = 1; i < shape.points.length; i++) {
                                        ctx.lineTo(shape.points[i].x, shape.points[i].y);
                                    }
                                    ctx.stroke(); // Brush usually just stroke
                                }
                            }
                            ctx.closePath();
                            ctx.shadowBlur = 0; // Reset
                        });
                    }
                });
                
                ctx.globalAlpha = 1.0;
            }
        }

        /**
         * Input Handling (Mouse & Touch)
         */
        class InputManager {
            constructor(app) {
                this.app = app;
                this.canvas = app.canvas;
                this.isDragging = false;
                this.startX = 0;
                this.startY = 0;
                this.currentShape = null;

                this.bindEvents();
            }

            getPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                // Scale for canvas resolution
                return {
                    x: (clientX - rect.left) * (this.canvas.width / rect.width),
                    y: (clientY - rect.top) * (this.canvas.height / rect.height)
                };
            }

            bindEvents() {
                const start = (e) => {
                    if (e.cancelable) e.preventDefault(); // Stop scroll on mobile
                    this.onDown(this.getPos(e));
                };
                const move = (e) => {
                    if (e.cancelable) e.preventDefault();
                    this.onMove(this.getPos(e));
                };
                const end = (e) => {
                   this.onUp();
                };

                this.canvas.addEventListener('mousedown', start);
                this.canvas.addEventListener('touchstart', start, {passive: false});

                window.addEventListener('mousemove', move);
                window.addEventListener('touchmove', move, {passive: false});

                window.addEventListener('mouseup', end);
                window.addEventListener('touchend', end);
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        // Delete Selection
                        if (this.app.state.selection) {
                            this.app.saveStateToHistory();
                            const shapes = this.app.getCurrentFrameShapes();
                            const idx = shapes.findIndex(s => s.id === this.app.state.selection);
                            if (idx > -1) shapes.splice(idx, 1);
                            this.app.state.selection = null;
                            this.app.renderer.render();
                        }
                    }
                    if (e.ctrlKey && e.key === 'z') this.app.editUndo();
                    if (e.key === 'F6') this.app.timeline.addKeyframe();
                    if (e.key === 'F7') this.app.timeline.clearKeyframe();
                    if (e.key === ' ') this.app.timeline.togglePlay();
                });
            }

            onDown(pos) {
                const { tool, activeLayerId } = this.app.state;
                // Check if layer locked
                const layer = this.app.getActiveLayer();
                if (layer.locked || !layer.visible) return;

                this.isDragging = true;
                this.startX = pos.x;
                this.startY = pos.y;
                
                // Ensure keyframe exists for drawing
                let kf = this.app.getCurrentKeyframe(layer);
                if (!kf) {
                    // Create keyframe automatically on draw if none exists
                    this.app.timeline.addKeyframe();
                    kf = this.app.getCurrentKeyframe(layer);
                }

                // If drawing on a frame that is technically previous keyframe, create new KF here?
                // Adobe Animate behavior: If you draw on a "hold" frame, it usually converts to keyframe.
                if (kf.frame !== this.app.state.currentFrame) {
                     this.app.timeline.addKeyframe(); // Splits the span
                }

                if (tool === 'rect') {
                    this.app.saveStateToHistory();
                    this.currentShape = {
                        id: Date.now().toString(),
                        type: 'rect',
                        x: pos.x, y: pos.y, width: 0, height: 0,
                        fill: this.app.state.fillColor,
                        stroke: this.app.state.strokeColor
                    };
                    this.app.getCurrentFrameShapes().push(this.currentShape);
                } else if (tool === 'circle') {
                    this.app.saveStateToHistory();
                    this.currentShape = {
                        id: Date.now().toString(),
                        type: 'circle',
                        x: pos.x, y: pos.y, width: 0, height: 0,
                        fill: this.app.state.fillColor,
                        stroke: this.app.state.strokeColor
                    };
                    this.app.getCurrentFrameShapes().push(this.currentShape);
                } else if (tool === 'brush') {
                    this.app.saveStateToHistory();
                    this.currentShape = {
                        id: Date.now().toString(),
                        type: 'path',
                        points: [{x: pos.x, y: pos.y}],
                        stroke: this.app.state.strokeColor,
                        fill: 'transparent',
                        lineWidth: 3
                    };
                    this.app.getCurrentFrameShapes().push(this.currentShape);
                } else if (tool === 'select') {
                    // Simple bounding box selection
                    const shapes = this.app.getCurrentFrameShapes();
                    // Reverse to select top-most
                    const clicked = [...shapes].reverse().find(s => {
                        if (s.type === 'rect' || s.type === 'circle') {
                            return pos.x >= s.x && pos.x <= s.x + s.width &&
                                   pos.y >= s.y && pos.y <= s.y + s.height;
                        }
                        // Path selection approx
                        if (s.type === 'path') {
                           return s.points.some(p => Math.abs(p.x - pos.x) < 10 && Math.abs(p.y - pos.y) < 10);
                        }
                        return false;
                    });
                    
                    if (clicked) {
                        this.app.state.selection = clicked.id;
                        this.app.ui.updateProperties();
                    } else {
                        this.app.state.selection = null;
                        this.app.ui.updateProperties();
                    }
                }
                
                this.app.renderer.render();
            }

            onMove(pos) {
                if (!this.isDragging) return;
                const { tool } = this.app.state;

                if (tool === 'rect' || tool === 'circle') {
                    this.currentShape.width = pos.x - this.startX;
                    this.currentShape.height = pos.y - this.startY;
                } else if (tool === 'brush') {
                    this.currentShape.points.push({x: pos.x, y: pos.y});
                } else if (tool === 'select' && this.app.state.selection) {
                    // Move object
                    const shapes = this.app.getCurrentFrameShapes();
                    const s = shapes.find(sh => sh.id === this.app.state.selection);
                    if (s && (s.type === 'rect' || s.type === 'circle')) {
                        const dx = pos.x - this.startX;
                        const dy = pos.y - this.startY;
                        s.x += dx;
                        s.y += dy;
                        this.startX = pos.x;
                        this.startY = pos.y;
                        this.app.ui.updateProperties(); // Update UI inputs
                    }
                }
                
                this.app.renderer.render();
            }

            onUp() {
                this.isDragging = false;
                this.currentShape = null;
            }
        }

        /**
         * Timeline Management
         */
        class TimelineManager {
            constructor(app) {
                this.app = app;
                this.canvas = document.getElementById('timeline-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('timeline-grid-container');
                
                // Interaction
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Header Click (Scrub)
                    if (y < 20) {
                        const frame = Math.floor(x / CONFIG.gridSize) + 1;
                        this.app.state.currentFrame = Math.max(1, frame);
                        this.updateUI();
                        this.app.renderer.render();
                    }
                    // Grid Click (Select Layer/Frame)
                    else {
                         const frame = Math.floor(x / CONFIG.gridSize) + 1;
                         const layerIndex = Math.floor((y - 20) / CONFIG.rowHeight);
                         if (this.app.state.layers[layerIndex]) {
                             this.app.state.activeLayerId = this.app.state.layers[layerIndex].id;
                             this.app.state.currentFrame = Math.max(1, frame);
                             this.updateUI();
                             this.app.renderer.render();
                         }
                    }
                });

                // Set canvas size
                this.canvas.width = CONFIG.gridSize * CONFIG.maxFrames;
                this.canvas.height = 200; // Dynamic based on layers?
            }

            render() {
                const ctx = this.ctx;
                const { layers, currentFrame } = this.app.state;
                
                // Resize height
                const neededHeight = 20 + (layers.length * CONFIG.rowHeight);
                if (this.canvas.height !== neededHeight) this.canvas.height = Math.max(neededHeight, 200);

                ctx.fillStyle = '#1e293b'; // Slate 800
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw Header
                ctx.fillStyle = '#334155';
                ctx.fillRect(0, 0, this.canvas.width, 20);
                
                // Draw Frames Numbers
                ctx.fillStyle = '#94a3b8';
                ctx.font = '10px sans-serif';
                for (let i = 1; i < CONFIG.maxFrames; i+=5) {
                    ctx.fillText(i, (i-1) * CONFIG.gridSize + 2, 14);
                }

                // Draw Grid & Keyframes
                layers.forEach((layer, idx) => {
                    const y = 20 + (idx * CONFIG.rowHeight);
                    
                    // Row bg (active?)
                    if (layer.id === this.app.state.activeLayerId) {
                        ctx.fillStyle = '#334155';
                        ctx.fillRect(0, y, this.canvas.width, CONFIG.rowHeight);
                    }
                    
                    // Horizontal Grid Lines
                    ctx.strokeStyle = '#475569';
                    ctx.beginPath();
                    ctx.moveTo(0, y + CONFIG.rowHeight);
                    ctx.lineTo(this.canvas.width, y + CONFIG.rowHeight);
                    ctx.stroke();

                    // Keyframes
                    const frames = Object.keys(layer.keyframes).map(Number).sort((a,b) => a-b);
                    
                    for (let i = 0; i < frames.length; i++) {
                        const f = frames[i];
                        const nextF = frames[i+1] || (f + 1); // Span until next
                        const span = (frames[i+1] ? frames[i+1] : CONFIG.maxFrames) - f;
                        
                        // Fill Span
                        const x = (f - 1) * CONFIG.gridSize;
                        const w = span * CONFIG.gridSize;
                        
                        // Tween color?
                        if (layer.keyframes[f].tween) {
                            ctx.fillStyle = 'rgba(59, 130, 246, 0.3)'; // Blue tint
                            ctx.fillRect(x, y + 2, w - 1, CONFIG.rowHeight - 4);
                            
                            // Arrow
                             ctx.strokeStyle = '#60a5fa';
                             ctx.beginPath();
                             ctx.moveTo(x + 5, y + CONFIG.rowHeight/2);
                             ctx.lineTo(x + w - 5, y + CONFIG.rowHeight/2);
                             ctx.stroke();
                        } else {
                            ctx.fillStyle = '#475569'; // Standard span
                            ctx.fillRect(x, y + 2, w - 1, CONFIG.rowHeight - 4);
                        }

                        // Vertical separator
                        ctx.fillStyle = '#1e293b';
                        ctx.fillRect(x + w - 1, y, 1, CONFIG.rowHeight);

                        // Diamond/Dot for Keyframe
                        ctx.fillStyle = 'white';
                        // if empty keyframe, hollow circle? skipping complexity
                        ctx.beginPath();
                        ctx.arc(x + CONFIG.gridSize/2, y + CONFIG.rowHeight/2, 3, 0, Math.PI*2);
                        ctx.fill();
                    }
                });
                
                // Vertical Grid Lines (every 5)
                ctx.strokeStyle = '#334155';
                for(let i=0; i<CONFIG.maxFrames; i+=1) {
                    ctx.beginPath();
                    ctx.moveTo(i * CONFIG.gridSize, 0);
                    ctx.lineTo(i * CONFIG.gridSize, this.canvas.height);
                    ctx.stroke();
                }

                // Playhead
                const phX = (currentFrame - 1) * CONFIG.gridSize;
                ctx.fillStyle = 'rgba(239, 68, 68, 0.5)'; // Red
                ctx.fillRect(phX, 0, CONFIG.gridSize, this.canvas.height);
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(phX, 0, CONFIG.gridSize, 20);
            }

            updateUI() {
                // Update Layers List HTML
                const list = document.getElementById('layers-list');
                list.innerHTML = '';
                this.app.state.layers.forEach((l, idx) => {
                    const div = document.createElement('div');
                    div.className = `h-[${CONFIG.rowHeight}px] px-2 flex items-center justify-between text-xs cursor-pointer hover:bg-slate-700 ${l.id === this.app.state.activeLayerId ? 'bg-slate-600' : ''}`;
                    div.style.height = CONFIG.rowHeight + 'px';
                    div.innerHTML = `
                        <span onclick="app.state.activeLayerId='${l.id}'; app.timeline.updateUI(); app.renderer.render();">${l.name}</span>
                        <div class="flex space-x-1">
                             <button onclick="app.timeline.toggleVis('${l.id}')">${l.visible ? 'üëÅÔ∏è' : 'üö´'}</button>
                             <button onclick="app.timeline.toggleLock('${l.id}')">${l.locked ? 'üîí' : 'üîì'}</button>
                        </div>
                    `;
                    list.appendChild(div);
                });

                document.getElementById('frame-indicator').innerText = '–ö–∞–¥—Ä: ' + this.app.state.currentFrame;
                
                // Checkbox Tween
                const layer = this.app.getActiveLayer();
                const kf = this.app.getCurrentKeyframe(layer);
                document.getElementById('chk-tween').checked = kf ? kf.data.tween : false;

                this.render();
            }

            // Operations
            addKeyframe() {
                const layer = this.app.getActiveLayer();
                if (!layer) return;
                const f = this.app.state.currentFrame;
                
                // Copy previous keyframe content
                const prevKf = this.app.getCurrentKeyframe(layer);
                const newShapes = prevKf ? JSON.parse(JSON.stringify(prevKf.data.shapes)) : [];
                
                this.app.saveStateToHistory();
                layer.keyframes[f] = {
                    shapes: newShapes,
                    tween: false
                };
                this.updateUI();
                this.app.renderer.render();
            }

            clearKeyframe() {
                const layer = this.app.getActiveLayer();
                if (!layer) return;
                this.app.saveStateToHistory();
                // Empty shapes
                layer.keyframes[this.app.state.currentFrame] = {
                    shapes: [],
                    tween: false
                };
                this.updateUI();
                this.app.renderer.render();
            }

            toggleTween() {
                 const layer = this.app.getActiveLayer();
                 const kf = this.app.getCurrentKeyframe(layer);
                 if (kf) {
                     kf.data.tween = !kf.data.tween;
                     this.updateUI();
                 }
            }
            
            togglePlay() {
                this.app.state.isPlaying = !this.app.state.isPlaying;
                const btn = document.getElementById('play-btn');
                btn.innerHTML = this.app.state.isPlaying 
                    ? '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>'
                    : '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
            }

            addLayer() {
                const id = 'layer' + (this.app.state.layers.length + 1) + Date.now();
                this.app.state.layers.unshift({ // Add to top
                    id: id,
                    name: '–°–ª–æ–π ' + (this.app.state.layers.length + 1),
                    visible: true,
                    locked: false,
                    keyframes: { 1: { shapes: [], tween: false } }
                });
                this.app.state.activeLayerId = id;
                this.updateUI();
            }
            
            deleteLayer() {
                if (this.app.state.layers.length <= 1) return;
                this.app.state.layers = this.app.state.layers.filter(l => l.id !== this.app.state.activeLayerId);
                this.app.state.activeLayerId = this.app.state.layers[0].id;
                this.updateUI();
                this.app.renderer.render();
            }

            nextFrame() {
                this.app.state.currentFrame++;
                this.updateUI();
                this.app.renderer.render();
            }
            prevFrame() {
                if(this.app.state.currentFrame > 1) {
                    this.app.state.currentFrame--;
                    this.updateUI();
                    this.app.renderer.render();
                }
            }
            
            toggleVis(id) {
                const l = this.app.state.layers.find(la => la.id === id);
                if (l) { l.visible = !l.visible; this.updateUI(); this.app.renderer.render(); }
            }
            toggleLock(id) {
                const l = this.app.state.layers.find(la => la.id === id);
                if (l) { l.locked = !l.locked; this.updateUI(); }
            }
        }

        class UIManager {
            constructor(app) {
                this.app = app;
            }
            updateProperties() {
                const sel = this.app.state.selection;
                const panel = document.getElementById('object-props');
                
                if (sel) {
                    panel.classList.remove('opacity-50', 'pointer-events-none');
                    const shapes = this.app.getCurrentFrameShapes();
                    const s = shapes.find(sh => sh.id === sel);
                    if (s) {
                        document.getElementById('obj-x').value = Math.round(s.x);
                        document.getElementById('obj-y').value = Math.round(s.y);
                        // Safe check for path types which don't have direct w/h editing
                        if (s.width) document.getElementById('obj-w').value = Math.round(s.width);
                        if (s.height) document.getElementById('obj-h').value = Math.round(s.height);
                        document.getElementById('obj-alpha').value = s.alpha !== undefined ? s.alpha : 1;
                        
                        // update color pickers to match selection
                        if (s.fill) document.getElementById('fill-color').value = s.fill;
                        if (s.stroke) document.getElementById('stroke-color').value = s.stroke;
                    }
                } else {
                    panel.classList.add('opacity-50', 'pointer-events-none');
                }
            }
        }

        // Initialize
        const app = new App();

        // Load Project if exists
        const saved = localStorage.getItem('vectorAnimator_project');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                app.state.layers = data.layers;
                app.state.width = data.width;
                app.state.height = data.height;
                app.state.fps = data.fps;
                
                document.getElementById('prop-w').value = data.width;
                document.getElementById('prop-h').value = data.height;
                document.getElementById('prop-fps').value = data.fps;
                
                app.resizeStage();
                app.timeline.updateUI();
            } catch(e) { console.error("Save load error", e); }
        }

    </script>
</body>
</html>
