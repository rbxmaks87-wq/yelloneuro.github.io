<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scene Creator</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        
        /* Custom Scrollbar for interaction panel if needed */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
    </style>
</head>
<body class="text-white antialiased">

    <!-- UI Panel -->
    <div class="absolute top-4 left-4 z-10 w-64 bg-gray-900/90 backdrop-blur-md border border-gray-700 rounded-xl shadow-2xl p-5 flex flex-col gap-4 transition-all">
        <h1 class="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">3D Editor</h1>
        
        <!-- Add Objects Section -->
        <div class="flex flex-col gap-2">
            <p class="text-xs text-gray-400 uppercase tracking-wider font-semibold">Добавить объект</p>
            <button id="add-cube" class="px-4 py-2 bg-gray-800 hover:bg-blue-600 border border-gray-700 rounded-lg transition-colors text-sm font-medium flex items-center gap-2">
                <span class="w-3 h-3 bg-blue-400 block rounded-sm"></span> Куб
            </button>
            <button id="add-sphere" class="px-4 py-2 bg-gray-800 hover:bg-purple-600 border border-gray-700 rounded-lg transition-colors text-sm font-medium flex items-center gap-2">
                <span class="w-3 h-3 bg-purple-400 block rounded-full"></span> Сфера
            </button>
            <button id="add-pyramid" class="px-4 py-2 bg-gray-800 hover:bg-yellow-600 border border-gray-700 rounded-lg transition-colors text-sm font-medium flex items-center gap-2">
                <span class="w-3 h-3 bg-yellow-400 block" style="clip-path: polygon(50% 0%, 0% 100%, 100% 100%);"></span> Пирамида
            </button>
        </div>

        <div class="h-px bg-gray-700 my-1"></div>

        <!-- Transform Tools -->
        <div class="flex flex-col gap-2">
            <p class="text-xs text-gray-400 uppercase tracking-wider font-semibold">Трансформация</p>
            <div class="flex gap-1 bg-gray-800 p-1 rounded-lg border border-gray-700">
                <button id="mode-translate" class="flex-1 py-1.5 rounded bg-blue-600 text-white text-xs font-medium transition-colors" title="Перемещение (T)">Move</button>
                <button id="mode-rotate" class="flex-1 py-1.5 rounded hover:bg-gray-700 text-gray-400 hover:text-white text-xs font-medium transition-colors" title="Вращение (R)">Rotate</button>
                <button id="mode-scale" class="flex-1 py-1.5 rounded hover:bg-gray-700 text-gray-400 hover:text-white text-xs font-medium transition-colors" title="Масштаб (S)">Scale</button>
            </div>
            <div class="flex items-center gap-2 mt-1">
                 <input type="checkbox" id="snap-toggle" class="rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-blue-500 h-4 w-4">
                 <label for="snap-toggle" class="text-xs text-gray-400 cursor-pointer">Привязка к сетке</label>
            </div>
        </div>

        <div class="h-px bg-gray-700 my-1"></div>

        <!-- Properties Section -->
        <div class="flex flex-col gap-2">
            <p class="text-xs text-gray-400 uppercase tracking-wider font-semibold">Свойства</p>
            <div id="selection-info" class="text-sm text-gray-500 italic mb-1">Ничего не выбрано</div>
            
            <div class="flex items-center gap-3">
                <label for="color-picker" class="text-sm">Цвет:</label>
                <input type="color" id="color-picker" class="w-full h-8 rounded cursor-pointer bg-transparent border-none" value="#ffffff" disabled>
            </div>
        </div>

        <div class="h-px bg-gray-700 my-1"></div>

        <!-- Project Section -->
        <div class="flex flex-col gap-2">
            <p class="text-xs text-gray-400 uppercase tracking-wider font-semibold">Проект</p>
            <div class="flex gap-2">
                <button id="btn-save" class="flex-1 px-3 py-2 bg-gray-800 hover:bg-green-700 border border-gray-700 rounded-lg transition-colors text-sm font-medium flex justify-center items-center gap-2" title="Сохранить как JSON">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                    Скачать
                </button>
                <button id="btn-load" class="flex-1 px-3 py-2 bg-gray-800 hover:bg-blue-700 border border-gray-700 rounded-lg transition-colors text-sm font-medium flex justify-center items-center gap-2" title="Загрузить JSON">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                    Загрузить
                </button>
                <input type="file" id="file-input" class="hidden" accept=".json">
            </div>
        </div>

        <div class="h-px bg-gray-700 my-1"></div>

        <!-- Actions Section -->
        <button id="clear-scene" class="w-full px-4 py-2 bg-red-900/50 hover:bg-red-600 text-red-200 hover:text-white border border-red-800 rounded-lg transition-colors text-sm font-medium">
            Очистить сцену
        </button>
        
        <div class="text-[10px] text-gray-500 text-center mt-2">
            ЛКМ: Вращение | ПКМ: Панорама<br>Колесико: Зум | Клик: Выбор
        </div>
    </div>

    <!-- Main Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Configuration ---
        const SCENE_BG_COLOR = 0x111827; // Tailwind Gray 900
        const GRID_COLOR = 0x374151;     // Tailwind Gray 700
        const GRID_CENTER_COLOR = 0x6b7280; // Tailwind Gray 500

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(SCENE_BG_COLOR);
        scene.fog = new THREE.Fog(SCENE_BG_COLOR, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Transform Controls ---
        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.addEventListener('dragging-changed', function (event) {
            controls.enabled = !event.value;
        });
        scene.add(transformControl);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- Helpers ---
        const gridHelper = new THREE.GridHelper(30, 30, GRID_CENTER_COLOR, GRID_COLOR);
        scene.add(gridHelper);

        // Group to hold user created objects
        const objectsGroup = new THREE.Group();
        scene.add(objectsGroup);

        // Selection Helper (Box)
        const selectionBox = new THREE.BoxHelper();
        selectionBox.material.depthTest = false;
        selectionBox.material.transparent = true;
        selectionBox.material.color.set(0x00ffff); // Cyan for visibility
        selectionBox.visible = false;
        scene.add(selectionBox);

        // --- State ---
        let selectedObject = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // --- Geometry Generators ---
        function createMaterial() {
            return new THREE.MeshStandardMaterial({ 
                color: Math.random() * 0xffffff,
                roughness: 0.3,
                metalness: 0.1
            });
        }

        function addCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = createMaterial();
            const cube = new THREE.Mesh(geometry, material);
            cube.position.y = 0.5;
            cube.position.x = (Math.random() - 0.5) * 4;
            cube.position.z = (Math.random() - 0.5) * 4;
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.userData.type = 'Куб';
            objectsGroup.add(cube);
            selectObject(cube);
        }

        function addSphere() {
            const geometry = new THREE.SphereGeometry(0.6, 32, 16);
            const material = createMaterial();
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.y = 0.6;
            sphere.position.x = (Math.random() - 0.5) * 4;
            sphere.position.z = (Math.random() - 0.5) * 4;
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            sphere.userData.type = 'Сфера';
            objectsGroup.add(sphere);
            selectObject(sphere);
        }

        function addPyramid() {
            // Cone with 4 radial segments looks like a pyramid
            const geometry = new THREE.ConeGeometry(0.7, 1, 4);
            const material = createMaterial();
            const pyramid = new THREE.Mesh(geometry, material);
            pyramid.position.y = 0.5;
            pyramid.position.x = (Math.random() - 0.5) * 4;
            pyramid.position.z = (Math.random() - 0.5) * 4;
            // Rotate to align flat side if desired, but default is fine
            pyramid.castShadow = true;
            pyramid.receiveShadow = true;
            pyramid.userData.type = 'Пирамида';
            objectsGroup.add(pyramid);
            selectObject(pyramid);
        }

        function clearScene() {
            // Remove all children from the objects group
            while(objectsGroup.children.length > 0){ 
                const obj = objectsGroup.children[0];
                obj.geometry.dispose();
                obj.material.dispose();
                objectsGroup.remove(obj); 
            }
            deselectObject();
        }

        // --- Selection Logic ---
        function selectObject(object) {
            selectedObject = object;
            
            // Attach Transform Controls
            transformControl.attach(object);

            // Update Visual Helper
            selectionBox.setFromObject(object);
            selectionBox.visible = true;

            // Update UI
            const colorInput = document.getElementById('color-picker');
            const infoText = document.getElementById('selection-info');
            
            colorInput.disabled = false;
            colorInput.value = '#' + object.material.color.getHexString();
            
            infoText.textContent = `Выбрано: ${object.userData.type || 'Объект'}`;
            infoText.className = "text-sm text-green-400 font-bold mb-1";
        }

        function deselectObject() {
            selectedObject = null;
            
            // Detach Transform Controls
            transformControl.detach();
            
            selectionBox.visible = false;
            
            const colorInput = document.getElementById('color-picker');
            const infoText = document.getElementById('selection-info');
            
            colorInput.disabled = true;
            colorInput.value = '#ffffff';
            
            infoText.textContent = "Ничего не выбрано";
            infoText.className = "text-sm text-gray-500 italic mb-1";
        }

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Intersect against objects in the group
            const intersects = raycaster.intersectObjects(objectsGroup.children);

            if (intersects.length > 0) {
                // Select the first intersected object
                selectObject(intersects[0].object);
            } else {
                // If clicked on empty space (but not dragging controls), deselect
                // We check if mouse moved significantly (drag vs click) usually, 
                // but for simple click logic:
                deselectObject();
            }
        }

        // --- Save & Load Logic ---
        function saveScene() {
            const data = objectsGroup.children.map(obj => ({
                type: obj.userData.type,
                pos: obj.position.toArray(),
                rot: obj.rotation.toArray(),
                scale: obj.scale.toArray(),
                color: obj.material.color.getHex()
            }));

            const json = JSON.stringify(data);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'scene.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadScene(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    clearScene(); // Clear existing

                    data.forEach(item => {
                        let geometry;
                        if (item.type === 'Куб') geometry = new THREE.BoxGeometry(1, 1, 1);
                        else if (item.type === 'Сфера') geometry = new THREE.SphereGeometry(0.6, 32, 16);
                        else if (item.type === 'Пирамида') geometry = new THREE.ConeGeometry(0.7, 1, 4);
                        
                        if (geometry) {
                            const material = new THREE.MeshStandardMaterial({ 
                                color: item.color,
                                roughness: 0.3,
                                metalness: 0.1
                            });
                            
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.fromArray(item.pos);
                            mesh.rotation.fromArray(item.rot);
                            mesh.scale.fromArray(item.scale);
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            mesh.userData.type = item.type;
                            
                            objectsGroup.add(mesh);
                        }
                    });
                } catch (err) {
                    alert("Ошибка загрузки файла сцены");
                    console.error(err);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // --- Event Listeners ---
        document.getElementById('btn-save').addEventListener('click', saveScene);
        document.getElementById('btn-load').addEventListener('click', () => document.getElementById('file-input').click());
        document.getElementById('file-input').addEventListener('change', loadScene);

        
        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // UI Buttons
        document.getElementById('add-cube').addEventListener('click', addCube);
        document.getElementById('add-sphere').addEventListener('click', addSphere);
        document.getElementById('add-pyramid').addEventListener('click', addPyramid);
        document.getElementById('clear-scene').addEventListener('click', clearScene);

        // Color Picker
        document.getElementById('color-picker').addEventListener('input', (e) => {
            if (selectedObject) {
                selectedObject.material.color.set(e.target.value);
            }
        });

        // Transform Tools
        function setTransformMode(mode) {
            transformControl.setMode(mode);
            
            ['translate', 'rotate', 'scale'].forEach(m => {
                const btn = document.getElementById(`mode-${m}`);
                // Reset base classes
                btn.className = "flex-1 py-1.5 rounded text-xs font-medium transition-colors";
                
                if (m === mode) {
                    btn.classList.add('bg-blue-600', 'text-white');
                } else {
                    btn.classList.add('bg-gray-800', 'text-gray-400', 'hover:bg-gray-700', 'hover:text-white');
                }
            });
        }

        document.getElementById('mode-translate').addEventListener('click', () => setTransformMode('translate'));
        document.getElementById('mode-rotate').addEventListener('click', () => setTransformMode('rotate'));
        document.getElementById('mode-scale').addEventListener('click', () => setTransformMode('scale'));

        document.getElementById('snap-toggle').addEventListener('change', (e) => {
            transformControl.setTranslationSnap(e.target.checked ? 1 : null);
            transformControl.setRotationSnap(e.target.checked ? THREE.MathUtils.degToRad(15) : null);
            transformControl.setScaleSnap(e.target.checked ? 0.25 : null);
        });

        // Canvas Click
        // Using 'pointerdown' is better for handling interactions but 'click' is simpler for this scope.
        // We need to distinguish between dragging (orbit) and clicking.
        let isDragging = false;
        let mouseDownTime = 0;

        renderer.domElement.addEventListener('mousedown', () => {
            isDragging = false;
            mouseDownTime = Date.now();
        });
        
        renderer.domElement.addEventListener('mousemove', () => {
            isDragging = true;
        });

        renderer.domElement.addEventListener('mouseup', (event) => {
            const timeDiff = Date.now() - mouseDownTime;
            // If mouse didn't move much and press was short, treat as click
            if (timeDiff < 200) {
                onMouseClick(event);
            }
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Optional: slight animation for selected object
            if (selectedObject) {
                // pulse effect or similar could go here
                selectionBox.update();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>